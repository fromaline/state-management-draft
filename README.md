
Мы уже поднимали этот вопрос стейт менеджмента раньше и, с учетом и моего личного ресерча, пришли к двум вариантам более менее отбросив все другие это:

1) [mobx](https://mobx.js.org/README.html)
2) [zustand](https://github.com/pmndrs/zustand) (или подобное, но он выглядит самым норм из всех)

==============

Я склоняюсь ко второму варианту и вот почему:

"софт" моменты:

1) Mobx добавляет много новых концептов которые требуют понимания для работы, то-есть грубо говоря человеку который хорошо знает реакт и хуки нужно будет потратить время и получить опыт с mobx специфическими вещами прежде чем начать на нем писать не как то, а хорошо и закладывая на будущее
2) Дока читается далеко не за 5 мин
3) прочитать и вникнуть в его сорцы в разумное время не представляется возможным, он довольно большой, это на случай если не хватило документации, хочется узнать получше, или раскурить какой тонкий момент или чтонить с связанное с производительностью у того же redux и zustand такой проблемы нет, код zustand читается целиком за 5 мин

"хард" моменты:

__1__ у mobx своя "магия", `observer` меняет семантику и самих компонентов, jsx и даже хуков, это лишний слой сложности и лишний уровень на котором могут возникать свои специфические проблемы. Я говорю не о том что он как то monkey-patch'ит реакт, а скорее о том что простой с виду код (условно):
```jsx
const [state] = useState(/* ... */)

return <p>{state}</p>
```
будет работать по разному в подключенных к mobx компонентах и не подключенных, это ломает "принцип минимального сюрприза" а также совместимость между модулями, а более технически - не позволит нам переиспользовать какие то части кода / кастом хуки и мб компоненты между подключенными к mobx компонентами и не подключенными что усложнит и переход и дальнейшую разработку. Если проще то кастом хук для работы с mobx стейтом и локальным стейтом должен уметь работать в первом случае с классом, во втором с классическими get() / set() имутабельного plain объекта.

__2__ вытекает из первого пункта, но mobx плохо сочетается в общем с подходом к разработке на хуках, это само по себе не плохо, но может усложнить нам жизнь, стандартный пример: нужно запилить доставание какого то состояния с сервера по API для этого пока все просто мы вызываем fetch и все, но по хорошему (и со временем) обычно нужно:
1) вызвать асинхронную функцию (fetch)
2) обработать состояние загрузки, ошибки
3) сделать throttle, обработать гонку между последующими запросами
4) отобразить результат, в момент когда он придет (что может не совпадать с жизненым циклом компонента)
5) запилить кеширование на нашей стороне, чтобы разные компоненты не обращались часто к одной и той-же апихе если например они "пересоздаются"
6) запилить шаринг этого стейта между всеми компонентами которые его используют
7) часто нужно инициировать загрузку без привязки к ui вообще, но например при старте приложения, а далее по интервалу, или обновлять данные когда в ui появляются компоненты их использующие

все эти пункты скорее всего приведут нас к архитектуре где каждый такой стейт выносится в отдельную модельку mobx тоесть в полноценный класс, и она довольно сильно разрастается. Тут мы возвращаемся к тому что
    - хуками тут особо делать уже и нечего
    - переиспользовать логику самих запросов, обработки ошибок, кеширование и прочим конкарренси между разными моделями будет сложно (потому что это классы) либо просто сильно повысит уровень абстракции (дженерики, паттерны, классовая композиция, упаси боже наследование), тут во первых не хочется идти по этому пути, а во вторых не хочется тратить много времени на то чтобы "защитить" наш код (линтерами, документацией, обучением новеньких) от скатывания в эту сторону
    - модельки mobx это не обычные классы, к ним предъявляется много условий которые могут начать мешать или просто усложнят архитектуру в сложном коде, думаю это чем то похоже на MVVM модель, которая не славится простотой архитектуры (см андройд фреймворк например)
    - все corner-case'ы конкретных компонентов в результате нужно будет поднимать до этой модели


__ванга мод он__: Смотря на код других людей / в других проектах и общаясь с разрабами у меня создалось впечатление что со временем, с постоянным ростом сложности и требований их проекты либо обрастают собственным "фреймворком" поверх mobx, либо в них тянут все больше других либ для того чтобы делать всякие асинхронные вещи на mobx. При этом теряя гибкость и реюзабельность небольших частей и обрастая все большим количеством концептов для изучения и обучения новеньких.

==============

Если говорить о минусах zustand то я бы назвал такие:

1) довольно новая штука, звезд на гитхабе много, но это не 10 лет в продакшене, хотя некоторые крупные проекты уже вполне успешно юзают
3) middleware - слабовато, я бы не использовал по причине не гибкости.
4) То что все базовое делается хуками, все сверх базовое - тоже хуками, и вообще везде хуки это конечно добавляет необходимости их хорошо знать. Делать всякие "нестандартные" штуки, мб даже сайд-эфекты только используя хуки. Мне не кажется это большой проблемой потому что
    1) сайд эфектов и так у всех в приложениях полно
    2) zustand не "заставляет" это делать, для более сложных штук все еще можно использовать классический контекст и классы-сервисы в нем или компонентный подход.
5) __Как и в mobx__ отсутствует "провайдер" тоесть нет привязки к entry-point реакта, хорошо для локальных сторов, плохо в экзотических ситуациях множественных точкек входа в реакт приложение, у нас такого плюс минус нет, но есть такой риск и может потребовать небольшого воркараунда.

==============

Если к плюсам zustand'a то для меня главное следующее:

софт:

1) zustand не добавляет вообще никаких новых концептов кроме самого стора и метода `create` для его создания, но и он в простом варианте полностью аналогичен реактовскому `createContext` и со схожей семантикой. Все в нем делается хуками, аналогичными `useState`
2) Дока читается за 5 мин
3) Сорцы читаются за 5 мин
4) То как именно он работает с реактом оч просто и полностью понятно, zustand не меняет семантику компонентов и сам использует все те же useState

хард:

1) Мы получаем метод максимально "не-инвазивно" рефачить свой код, так как сторы zustand'а не требуют никакой дополнительной обвязки. Использование кастомных хуков или уже готовых компонентов с ними также не требует лишних телодвижений, со стором zustand'a можно работать полностью также как и со стейтом полученным из useState, хуки зустанда почти ничем не отличаются от любых других хуков

__ванга мод он__: В будущем хочется минимизировать количество либ, подходов или концептов для работы над проектом (юзать хуки), и максимизировать реюзабельность всех наших "кирпичиков", только так, как мне кажется, на длинном интервале и с растущей сложностью и вариабильностью можно контролировать сложность кодовой базы. А чем меньше у нас либ, концептов и интерфейсов которые нужно поддержать и интегрировать, тем проще писать универсальные "кирпичики".

==============

__Off-TopIc__

Мне в принципе нравится подход которым следуют разработчики nextjs и разработичики на nextjs а именно:

1) Компоненты просто юзают один кастом-хук для получения данных с апи
	1) На этом уровне можно подменять всякое для юнит тестов
2) Кастом хук юзает useSwr чтобы описать какой именно запрос послать
	1) На этом уровне можно также управлять синхронизацией разного стейта из разных источников
3) useSwr держит некоторое глобальное состояние чтобы шарить стейт,  дедуплицировать запросы по ключам, работать с кешом и ревалидацией данных
	1) На этом уровне мы можем мокать запросы
4) (Опционально service-worker) - оффлайн данные, Browser's Cache API
5) CDN / edge middleware / reverse-proxy менеджат кеш чтобы контролировать нагрузку на сервер и управлять "актуальностью" тех или иных данных во времени, при этом шаря их между всеми пользователями если мы говорим об уровнях начиная с CDN
	1) На этом уровне мы делаем кроме кеша еще и авторизацию, "адаптеры" и прокси под разные бекенды и пр

Разделение концептов и обязаностей довольно хорошее, при этом каждый уровень тут выполняет довольно узкую задачу которую легко по разному крутить не смешивая все в кучу.

==============

Прикладываю свой черновик с решением вышеописанной задачи про API на zustand'e для более предметного разговора в этом репозитории.

Потыкать можно тут [https://vacavaca.github.io/state-management-draft/](https://vacavaca.github.io/state-management-draft/)

Start from the App then app/ then go to the lib/
